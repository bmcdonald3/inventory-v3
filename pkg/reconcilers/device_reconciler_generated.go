// Code generated by fabrica-codegen. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
// This file provides the generated boilerplate for Device reconciler.
//
// The reconciler pattern enables declarative infrastructure management by:
//   - Automatically reconciling Spec (desired state) with Status (observed state)
//   - Reacting to resource changes via events
//   - Integrating with the workflow engine for complex operations
//
// To customize reconciliation logic, edit device_reconciler.go
package reconcilers

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/example/inventory-v3/pkg/resources/device"
	"github.com/openchami/fabrica/pkg/events"
	"github.com/openchami/fabrica/pkg/reconcile"
)

// DeviceReconciler reconciles Device resources.
//
// This reconciler:
//   - Observes Device resources and updates their Status
//   - Emits events when significant state changes occur
//   - Can trigger workflows for complex operations
//   - Runs periodically and on resource changes
//
// The implementation of reconcileDevice() is in device_reconciler.go
type DeviceReconciler struct {
	reconcile.BaseReconciler

	// Custom fields are defined in device_reconciler.go
}

// NewDefaultDeviceReconciler creates a default Device reconciler.
//
// This is called during server startup to register the reconciler.
//
// Parameters:
//   - client: Client for accessing resource storage
//   - eventBus: Event bus for publishing events
//
// Returns:
//   - *DeviceReconciler: Initialized reconciler
func NewDefaultDeviceReconciler(client reconcile.ClientInterface, eventBus events.EventBus) *DeviceReconciler {
	return &DeviceReconciler{
		BaseReconciler: reconcile.BaseReconciler{
			Client:   client,
			EventBus: eventBus,
			Logger:   reconcile.NewDefaultLogger(),
		},
	}
}

// GetResourceKind returns the resource kind this reconciler handles.
func (r *DeviceReconciler) GetResourceKind() string {
	return "Device"
}

// Reconcile brings Device to desired state.
//
// This method is called:
//   - When a Device resource is created/updated/deleted
//   - Periodically (every 5 minutes by default)
//   - When manually triggered via API
//
// The reconciler should:
//  1. Read the Spec (desired state)
//  2. Observe the actual state
//  3. Update Status to reflect observed state
//  4. Take actions to align actual with desired
//  5. Emit events for significant changes
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The Device resource to reconcile
//
// Returns:
//   - Result: Indicates if/when to requeue
//   - error: If reconciliation failed
func (r *DeviceReconciler) Reconcile(ctx context.Context, resource interface{}) (reconcile.Result, error) {
	// 1. Assert to raw message
	raw, ok := resource.(json.RawMessage)
	if !ok {
		err := fmt.Errorf("received resource is not json.RawMessage, but %T", resource)
		r.Logger.Errorf(err.Error())
		// Do not requeue, this is a poison pill
		return reconcile.Result{}, nil
	}

	// 2. Unmarshal it into the correct type
	var res device.Device // This is the typed struct
	if err := json.Unmarshal(raw, &res); err != nil {
		err := fmt.Errorf("failed to unmarshal resource: %w", err)
		r.Logger.Errorf(err.Error())
		// Do not requeue, this is a poison pill
		return reconcile.Result{}, nil
	}

	r.Logger.Debugf("Reconciling Device %s/%s", res.Kind, res.GetUID())

	// Call custom reconciliation logic (now passing &res)
	if err := r.reconcileDevice(ctx, &res); err != nil {
		r.Logger.Errorf("Reconciliation failed for Device %s: %v", res.GetUID(), err)

		// Set error condition
		r.SetCondition(&res, "Ready", "False", "ReconcileError", err.Error())

		// Requeue with backoff (30 seconds)
		return reconcile.Result{Requeue: true, RequeueAfter: 30 * time.Second}, err
	}

	// Set success condition
	r.SetCondition(&res, "Ready", "True", "ReconcileSuccess", "Reconciliation successful")

	// Update status in storage
	if err := r.UpdateStatus(ctx, &res); err != nil {
		r.Logger.Errorf("Failed to update status for Device %s: %v", res.GetUID(), err)
		return reconcile.Result{Requeue: true, RequeueAfter: 10 * time.Second}, err
	}

	// Comment out event emission to prevent infinite loop
	/*
		// Emit reconciliation event
		eventType := "io.openchami.inventory.devices.reconciled"
		if err := r.EmitEvent(ctx, &res, eventType); err != nil {
			r.Logger.Warnf("Failed to emit event for Device %s: %v", res.GetUID(), err)
			// Don't fail reconciliation if event emission fails
		}
	*/

	// Requeue after 5 minutes for periodic reconciliation
	return reconcile.Result{RequeueAfter: 5 * time.Minute}, nil
}
